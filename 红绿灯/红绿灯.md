<h1 id="TKfd4">结构</h1>
1.让vscode可以一帧帧读取视频

2.识别到红色和绿色区域

3.生成色框

4.同时显示出颜色（其实在前面的基础上写一个输出就行）

<h1 id="T5r6r">part1让vscode可以一帧帧读取视频</h1>
![](https://cdn.nlark.com/yuque/0/2025/png/61614341/1761356243216-b7c81598-0dcb-40db-a779-ba25790650ba.png)

```plain
#include<opencv2/opencv.hpp>
#include<iostream>
using namespace cv;
using namespace std;
int main(){
while(true){//while循环用来保证读取多帧，不然放一帧就停止了
VideoCapture cap;//设置一个cap变量，用于打开视频
cap.open("TrafficLight.mp4");//打开视频
Mat frame...//设置所需变量
cap>>frame;//把视频从cap给到frame
//imshow,waitKey同时出现
imshow("生成后的视频名"，文件名对应的变量名在这里是frame)；
if(waitKey(30)=='q')//套用if循环来播放
{break;}//这里首先设置了播放速度（30），然后指定按到q的时候程序终止
;}
return 0;

}
```

<h1 id="AIhfN">part2.识别到红色和绿色区域</h1>
1.识别

```plain
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;
int main(){
    VideoCapture cap;
    cap.open("TrafficLight.mp4");
    while(true){
    if(cap.isOpened()){
        Mat frame,red_mask,green_mask;
        Mat hsv;
        cap >> frame;         
        cvtColor(frame, hsv, COLOR_BGR2HSV);  //这一步是把frame的类型由BGR转成hsv便于计算机理解
        inRange(hsv, Scalar(0, 120, 70), Scalar(10, 255, 255), red_mask);
        inRange(hsv,Scalar(35, 255, 255),Scalar(85, 50, 50),green_mask);
        imshow("红绿灯灯灯",frame);
        imshow("红色地图", red_mask); 
        if(waitKey(30)=='q'){
            break;
        }; } 
        
    }
    return 0; }
```

<font style="background-color:#FBDE28;">用inRange函数，找到红色和绿色区域，注意！！这时候绿色识别和红色识别是在两个视频里的</font>

<font style="background-color:#FBDE28;">inRange函数表示上下限的时候记得下限在前，上限在后</font>

<font style="background-color:#FBDE28;">拼接可以用vconcat函数但是这种是两个图像竖直或水平拼接</font>

```plain
vconcat(输入图像1, 输入图像2, 输出图像);
Mat image1, image2, result;
vconcat(image1, image2, result);  // 把image2放在image1下面
```

<h1 id="S8P1e">part3.4</h1>
识别到红色和绿色区域，计算面积，去除噪点（不然都是框），然后显示文字

1.当使用多种颜色识别的时候，要建立列表中的列表

~~最外层列表来存放颜色识别，内层列表来存放单个颜色识别~~

这个理解不大对

<font style="color:rgb(15, 17, 21);">vector<vector<Point>> contours：</font>**<font style="color:rgb(15, 17, 21);">一个颜色</font>**<font style="color:rgb(15, 17, 21);">中的</font>**<font style="color:rgb(15, 17, 21);">多个物体</font>**

<font style="color:rgb(15, 17, 21);">外层vector：不同的</font>**<font style="color:rgb(15, 17, 21);">物体</font>**

<font style="color:rgb(15, 17, 21);">内层vector：每个物体的</font>**<font style="color:rgb(15, 17, 21);">形状边界点</font>**

<font style="color:rgb(15, 17, 21);">用来处理一个掩码中有多个物体的情况，</font>~~<font style="color:rgb(15, 17, 21);">可以理解为，外层识别颜色，内层识别物体</font>~~

<font style="color:rgb(15, 17, 21);">外层是多个物体，而内层把这个定位到每一个物体（这样才能进行筛选）</font>

**<font style="color:rgb(15, 17, 21);">注意</font>**<font style="color:rgb(15, 17, 21);">颜色识别和物体识别不能放一起</font>

<font style="color:rgb(15, 17, 21);">颜色识别inRange，像素层面找到对应的像素块</font>

<font style="color:rgb(15, 17, 21);">物体识别：找到类似的物体</font>

```plain
vector<vector<Point>> red_contours;
//
```

2.要使用putText函数来添加文字

<h2 id="ed822506"><font style="color:rgb(15, 17, 21);">整体功能：</font></h2>
**<font style="color:rgb(15, 17, 21);">在红色区域周围画红色矩形框，并标注"RED"文字</font>**

```plain
#include <opencv2/opencv.hpp>
using namespace cv;
using namespace std;

int main() {
    VideoCapture cap("TrafficLight.mp4");
    
    while(true) {
        Mat frame, hsv, red_mask, green_mask;
        cap >> frame;
        if(frame.empty()) break;
        
        cvtColor(frame, hsv, COLOR_BGR2HSV);
        
        // 提取红色和绿色
        inRange(hsv, Scalar(0, 120, 70), Scalar(10, 255, 255), red_mask);
        inRange(hsv, Scalar(35, 50, 50), Scalar(85, 255, 255), green_mask);  // 修正范围
        
        // 在原视频上标记红色区域
        vector<vector<Point>> red_contours;
        findContours(red_mask, red_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
        for(auto contour : red_contours) {
            if(contourArea(contour) > 100) {
                Rect box = boundingRect(contour);
                rectangle(frame, box, Scalar(0, 0, 255), 3);  // 红色框
                putText(frame, "RED", Point(box.x, box.y-10), 
                        FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 0, 255), 2);
            }
        }
        
        // 在原视频上标记绿色区域
        vector<vector<Point>> green_contours;
        findContours(green_mask, green_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
        for(auto contour : green_contours) {
            if(contourArea(contour) > 100) {
                Rect box = boundingRect(contour);
                rectangle(frame, box, Scalar(0, 255, 0), 3);  // 绿色框
                putText(frame, "GREEN", Point(box.x, box.y-10), 
                        FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 0), 2);
            }
        }
        
        imshow("红绿灯检测 - 红色和绿色", frame);  // 只显示一个视频，包含两种颜色的标记
        
        if(waitKey(30) == 'q') break;
    }
    return 0;
}
```

<h2 id="74e2cffb"><font style="color:rgb(15, 17, 21);">逐行详细解释：</font></h2>
<h3 id="0d5839ba"><font style="color:rgb(15, 17, 21);">第1行：声明轮廓容器</font></h3>
```plain
vector<vector<Point>> red_contours;
```

<font style="color:rgb(15, 17, 21);">vector<vector<Point>>：创建一个</font>**<font style="color:rgb(15, 17, 21);">列表的列表</font>**

**<font style="color:rgb(15, 17, 21);background-color:#FBE4E7;">注意point一定要大写</font>**

<font style="color:rgb(15, 17, 21);">red_contours：变量名，用来存储找到的所有红色区域的轮廓</font>

**<font style="color:rgb(15, 17, 21);background-color:#FBDE28;">作用</font>**<font style="color:rgb(15, 17, 21);background-color:#FBDE28;">：</font><font style="color:rgb(15, 17, 21);">准备一个空容器，等着装红色区域的边界信息</font>

<h3 id="a34ba21e"><font style="color:rgb(15, 17, 21);">第2行：查找轮廓</font></h3>
```plain
findContours(输入图像, 输出轮廓, 检索模式, 近似方法);
```

```plain
findContours(red_mask, red_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
```

<font style="background-color:#FBDE28;">掩码也是一个图像</font>

<font style="color:rgb(15, 17, 21);">findCountours是一个函数</font>

<font style="background-color:#FBDE28;">参数解释：</font>

red_mask：输入图像（黑白掩码，白色=红色区域）

red_contours：输出参数，找到的轮廓都存到这里

RETR_EXTERNAL：只检测最外层轮廓（不检测轮廓内部的轮廓）

CHAIN_APPROX_SIMPLE：压缩轮廓点（只保留关键点，节省内存）

执行后：red_contours 里面装满了所有红色区域的边界坐标

<h3 id="b1aa2f51"><font style="color:rgb(15, 17, 21);">第3行：遍历每个轮廓</font></h3>
```plain
for(auto contour : red_contours) {
```

<font style="color:rgb(15, 17, 21);background-color:#FBDE28;">contour：</font><font style="color:rgb(15, 17, 21);">当前正在处理的轮廓</font>

<font style="color:rgb(15, 17, 21);background-color:#FBDE28;">for(auto contour : red_contours)：</font><font style="color:rgb(15, 17, 21);">对 red_contours 中的每个轮廓执行循环体内的代码</font>

<h3 id="43c5bfff"><font style="color:rgb(15, 17, 21);">第4行：面积过滤</font></h3>


```plain
if(contourArea(contour) > 100) {
```

1。contourArea(contour)：计算当前轮廓的面积（像素数量）

2。> 100：只处理面积大于100像素的轮廓

**<font style="color:rgb(15, 17, 21);">3.目的</font>**<font style="color:rgb(15, 17, 21);">：过滤掉小噪点，只处理有意义的红色区域</font>

![](https://cdn.nlark.com/yuque/0/2025/png/61614341/1761362670268-cef2c233-b8c2-44c1-9c14-26f68273c188.png)

要是不过滤就会出现很多框

![](https://cdn.nlark.com/yuque/0/2025/png/61614341/1761362725089-bd7e951a-5d16-47e6-a0a2-318db9e47e1a.png)

奇奇怪怪的

<h3 id="9ffeaff7"><font style="color:rgb(15, 17, 21);">第5行：计算包围矩形</font></h3>
```plain
Rect box = boundingRect(contour);
```

笔记

```plain
boundingRect(contour)：计算能完全包围当前轮廓的最小矩形
 rect是opencv中的类，box也是自定义的变量名
Rect box：包含矩形的信息：
box.x：矩形左上角的x坐标
box.y：矩形左上角的y坐标
box.width：矩形宽度
 box.height：矩形高度
```

<font style="color:rgb(15, 17, 21);"></font>

<h2 id="ef2686b8"><font style="color:rgb(15, 17, 21);">错误代码：</font></h2>
```plain
Rect redbox = boundingRect(red_contours);  //  错误！
                              这个地方应该是写一个轮廓，而不是一个轮廓类
```

总代码，不会弹出视频框，并且会把下面的redbox或者greenbox标红

所以要改正的话，需要加上while/for循环，依次提取每一个轮廓进行加框

<h3 id="a2dbd5c9"><font style="color:rgb(15, 17, 21);">第6行：画红色矩形框</font></h3>
```plain
rectangle(frame, box, Scalar(0, 0, 255), 3);
rectangle(目标图像, 矩形位置, 颜色, 线宽);
```

**<font style="color:rgb(15, 17, 21);background-color:#FBDE28;">笔记</font>****<font style="color:rgb(15, 17, 21);">参数解释：</font>**

```plain
 frame：要在哪张图像上画（原始彩色图像）
box：矩形的位置和大小（这个也是自定义的，比如说我上面定义的是红框redbox这里就写redbox）
Scalar(0, 0, 255)：颜色（B=0, G=0, R=255 → 红色）
3：线条粗细（3像素）
```

<h3 id="2514ef2a"><font style="color:rgb(15, 17, 21);">第7-8行：添加文字标签</font></h3>


```plain
putText(frame, "RED", Point(box.x, box.y-10), 
        FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 0, 255), 2);
```

**<font style="color:rgb(15, 17, 21);background-color:#FBDE28;">参数解释：（理解）</font>**

```plain
frame：目标图像
"RED"：要显示的文字
Point(box.x, box.y-10)：文字位置（矩形左上角往上10像素）
FONT_HERSHEY_SIMPLEX：字体样式
 0.8：字体大小
Scalar(0, 0, 255)：文字颜色（红色）
2：文字粗细
```



+ ![](https://cdn.nlark.com/yuque/0/2025/png/61614341/1761370645119-fd3dc9a0-cf11-4f0e-8d7d-000400b0f59e.png)hsv中红色范围需要合并，

```plain
// 红色需要两个范围合并
Mat red_mask1, red_mask2, red_mask;
inRange(hsv, Scalar(0, 150, 100), Scalar(10, 255, 255), red_mask1);    // 第一段
inRange(hsv, Scalar(170, 150, 100), Scalar(180, 255, 255), red_mask2); // 第二段
red_mask = red_mask1 | red_mask2;  // 合并
```



```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;
int main(){
    VideoCapture cap;
    cap.open("TrafficLight.mp4");
    while(true){
        if(cap.isOpened()){
            Mat frame,red_mask,green_mask,smallframe;
            Mat hsv;
            cap >> frame;         
            cvtColor(frame, hsv, COLOR_BGR2HSV);  //这一步是把frame的类型由BGR转成hsv便于计算机理解
            inRange(hsv, Scalar(170, 120, 100), Scalar(180, 255, 255), red_mask);
            inRange(hsv,Scalar(35, 190, 120),Scalar(90, 255, 255),green_mask);
            //调节hsv，满足绿色和红色的上限
            vector<vector<Point>>red_contours;
            findContours(red_mask, red_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
            for(auto redcontour:red_contours)
                {
                    if(contourArea(redcontour) > 17000) {
                        Rect redbox = boundingRect(redcontour);
                        rectangle(frame, redbox, Scalar(225, 0, 0), 3);
                        putText(frame, "RED", Point(200, 400), 
                            FONT_HERSHEY_SIMPLEX, 1.8, Scalar(225, 0, 0), 2);};}
            vector<vector<Point>>green_contours;
            findContours(green_mask,green_contours,RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
            for(auto greencontour:green_contours){
                if(contourArea(greencontour) > 17000) {
                    Rect greenbox= boundingRect(greencontour);
                    rectangle(frame,greenbox,Scalar(225,0,0),3);
                    putText(frame, "GREEN", Point(200,400), 
                        FONT_HERSHEY_SIMPLEX, 1.8, Scalar(225, 0, 0), 2);}}
            resize(frame, smallframe, Size(), 0.5, 0.5);
            imshow("红绿灯灯灯",smallframe);
            if(waitKey(30)=='q'){
                break;
            }; } 

    }
    return 0; }
```

<font style="background-color:#FBDE28;">出大问题了，没有用cmake，将程序拆开放入cmake里，每一步都有解释</font>

```cpp
#0.进入目录
cd /home/zhao/Desktop/c/HelloCV/TrafficLight//进入目录
# 1. 创建构建目录
    
mkdir build 
cd build

# 2. 运行 CMake（会执行上述所有步骤）
cmake ..

# 3. 编译项目
make

# 4. 运行程序
./traffic_light
```

CMakeList.txt

```cpp
cmake_minimum_required(VERSION 3.10)
    //限制cmake的最低版本
project(TrafficLight)
//定义项目名称
find_package(OpenCV REQUIRED)
//查找opencv库，查找位置和配置
add_executable(traffic_light ../main.cpp ../video_process.cpp)
//添加要用到的文件
target_link_libraries(traffic_light ${OpenCV_LIBS})
//target生成文件
set(CMAKE_CXX_STANDARD 11)
//设置c++标准
```

main.cpp

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include "video_process.h"

using namespace cv;
using namespace std;

int main() {
    VideoCapture cap;

    cap.open("TrafficLight.mp4");
    //打开文件
    
    // 获取原视频的帧率和尺寸
    double fps = cap.get(CAP_PROP_FPS);
    int width = cap.get(CAP_PROP_FRAME_WIDTH);
    int height = cap.get(CAP_PROP_FRAME_HEIGHT);
    
    cout << "Video opened successfully: " << width << "x" << height << " FPS: " << fps << endl;
    
    // 创建 VideoWriter 来保存结果视频，使生成文件为avi.
    VideoWriter writer;
    writer.open("result.avi", 
                VideoWriter::fourcc('M','J','P','G'), 
                fps, 
                Size(width, height));
    
    while(true) {
        Mat frame, smallframe;
        cap >> frame;
        
        if (frame.empty()) {
            cout << "Video ended" << endl;
            break;
        }
        
        // 处理视频帧
        processVideoFrame(frame);
        
        // 保存处理后的帧到输出视频
        writer.write(frame);
        
        // 显示缩小后的帧
        resize(frame, smallframe, Size(), 0.5, 0.5);//缩小页面，要不然看不全
        imshow("红绿灯灯灯", smallframe);
        
        if(waitKey(30) == 'q') {
            break;
        }
    }
    
    // 释放资源，avi.要释放资源
    writer.release();
    cap.release();
    destroyAllWindows();
    
    cout << "视频已保存为 result.avi" << endl;
    
    return 0; 
}
```





video_process.cpp

```cpp
#include "video_process.h"
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

bool processVideoFrame(Mat& frame) {
    Mat hsv, red_mask, green_mask;
    //定义几个变量
    cvtColor(frame, hsv, COLOR_BGR2HSV);
    //将grb转成hsv
    inRange(hsv, Scalar(170, 120, 100), Scalar(180, 255, 255), red_mask);
    inRange(hsv, Scalar(35, 190, 120), Scalar(90, 255, 255), green_mask);
    //设定范围
    vector<vector<Point>> red_contours;
    findContours(red_mask, red_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
    //寻找区域
    for(auto redcontour : red_contours) {
        if(contourArea(redcontour) > 17000) {//防止干扰，降低噪点设置了面积限制
            Rect redbox = boundingRect(redcontour);
            rectangle(frame, redbox, Scalar(0, 0, 225), 3);//添加框框，颜色，宽度
            //文字设置，添加，括号内是位置
            putText(frame, "RED", Point(100, 100), 
                    FONT_HERSHEY_SIMPLEX, 1.8, Scalar(0, 0, 225), 2);
        }
    }
    //下面的绿色和上面一样
    vector<vector<Point>> green_contours;
    findContours(green_mask, green_contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
    
    for(auto greencontour : green_contours) {
        if(contourArea(greencontour) > 17000) {
            Rect greenbox = boundingRect(greencontour);
            rectangle(frame, greenbox, Scalar(0, 225, 0), 3);
            putText(frame, "GREEN", Point(100, 100), 
                    FONT_HERSHEY_SIMPLEX, 1.8, Scalar(0, 225, 0), 2);
        }
    }
    
    return true;
}

```

```cpp
#ifndef VIDEO_PROCESS_H
#define VIDEO_PROCESS_H//头文件保护

#include <opencv2/opencv.hpp>//包含opencv库

bool processVideoFrame(cv::Mat& frame);//函数声明

#endif//结束头文件保护
```

![](https://cdn.nlark.com/yuque/0/2025/png/61614341/1761390077680-0e79ac79-7c80-42d8-a88c-feafb522da46.png)生成的





